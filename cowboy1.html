<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Mall Dice - Prototype</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #2a2a2a;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #3a4a5c;
        }

        #physics-canvas {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0.3;
        }

        /* UI Panels */
        .ui-container {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            min-width: 180px;
            z-index: 10;
        }

        .ui-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .dice-bag {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            min-width: 220px;
            max-width: 250px;
            z-index: 10;
        }

        .dice-bag h3 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .dice-group {
            background: rgba(50,50,50,0.7);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dice-group-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dice-group-emoji {
            font-size: 18px;
        }

        .dice-group-name {
            font-size: 12px;
        }

        .dice-group-count {
            font-weight: bold;
            font-size: 14px;
        }

        /* Column Matcher */
        .column-matcher {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 300px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            z-index: 5;
        }

        .matcher-column {
            width: 60px;
            height: 100%;
            border-left: 2px dashed rgba(255,255,255,0.3);
            border-right: 2px dashed rgba(255,255,255,0.3);
            display: flex;
            flex-direction: column-reverse;
            cursor: pointer;
            position: relative;
        }

        .matcher-column.selected {
            background: rgba(255,255,255,0.2);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* Dice Elements */
        .dice {
            position: absolute;
            width: 40px;
            height: 40px;
            perspective: 600px;
            pointer-events: none;
        }

        .dice-inner {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
        }

        .dice-face {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            backface-visibility: hidden;
            background: #f0f0f0;
        }

        /* 3D Cube Faces */
        .dice-face:nth-child(1) { transform: rotateY(0deg) translateZ(20px); }
        .dice-face:nth-child(2) { transform: rotateY(90deg) translateZ(20px); }
        .dice-face:nth-child(3) { transform: rotateY(180deg) translateZ(20px); }
        .dice-face:nth-child(4) { transform: rotateY(-90deg) translateZ(20px); }
        .dice-face:nth-child(5) { transform: rotateX(90deg) translateZ(20px); }
        .dice-face:nth-child(6) { transform: rotateX(-90deg) translateZ(20px); }

        /* Pegs */
        .peg {
            position: absolute;
            border-radius: 50%;
            background: #4a7ba7;
            pointer-events: none;
            z-index: 1;
        }

        /* Dice Stack (Lobby) */
        .dice-stack {
            position: fixed;
            bottom: 320px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
            z-index: 10;
            max-width: 80%;
            flex-wrap: wrap;
            justify-content: center;
        }

        .dice-stack-item {
            width: 50px;
            height: 50px;
            background: rgba(70,70,70,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        .dice-stack-item:hover {
            transform: scale(1.1);
            background: rgba(90,90,90,0.8);
        }

        .dice-stack-item.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Buttons */
        .make-baby-btn {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #4a4a9c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .make-baby-btn:hover:not(:disabled) {
            background: #5a5aac;
        }

        .make-baby-btn:disabled {
            background: #333;
            color: #888;
            cursor: not-allowed;
        }

        /* Animations */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes float-up {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-100px); opacity: 0; }
        }

        .match-indicator {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: yellow;
            text-shadow: 0 0 10px rgba(255,255,0,0.8);
            animation: blink 0.5s infinite;
            z-index: 20;
            pointer-events: none;
        }

        .bonus-effect {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #ffeb3b;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 30;
            animation: float-up 2s forwards;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- UI Panel -->
        <div class="ui-container">
            <div class="ui-item">
                <span>üíØ Score:</span>
                <span id="score-value">0</span>
            </div>
            <div class="ui-item">
                <span>üßü‚Äç‚ôÇÔ∏è Zombies:</span>
                <span id="zombie-value">5</span>
            </div>
            <div class="ui-item">
                <span>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Humans:</span>
                <span id="human-value">10</span>
            </div>
            <div class="ui-item">
                <span>üë∂ Babies:</span>
                <span id="baby-value">3</span>
            </div>
            <div class="ui-item">
                <span>üè† Shelters:</span>
                <span id="shelter-value">0</span>
            </div>
            <button class="make-baby-btn" id="make-baby-btn">Make Baby (2 Humans)</button>
        </div>

        <!-- Dice Bag -->
        <div class="dice-bag">
            <h3>Available Dice</h3>
            <div id="dice-bag-content"></div>
        </div>

        <!-- Dice Stack -->
        <div class="dice-stack" id="dice-stack"></div>

        <!-- Column Matcher -->
        <div class="column-matcher" id="column-matcher"></div>

        <!-- Physics Canvas -->
        <canvas id="physics-canvas"></canvas>
    </div>

    <script>
        // Matter.js aliases
        const Engine = Matter.Engine;
        const Render = Matter.Render;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Events = Matter.Events;

        // Game State
        const gameState = {
            score: 0,
            zombies: 5,
            humans: 10,
            babies: 3,
            shelters: 0,
            columnStacks: [[], [], [], [], [], [], []],
            dicePool: {
                mall: 20,
                food: 15,
                arcade: 15,
                clothing: 15,
                zoo: 15,
                themepark: 15,
                zombies: 0
            },
            selectedColumn: null,
            parentsDice: [],
            activeDice: []
        };

        // Emoji sets
        const emojiSets = {
            mall: ['üõçÔ∏è', 'üõí', 'üí∞', 'üí≥', 'üë®', 'üë©']
        };

        // Initialize Physics Engine
        const canvas = document.getElementById('physics-canvas');
        const engine = Engine.create();
        engine.gravity.y = 0.5;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent'
            }
        });

        // Create boundaries
        const ground = Bodies.rectangle(
            window.innerWidth / 2,
            window.innerHeight - 10,
            window.innerWidth,
            20,
            { isStatic: true, render: { visible: false } }
        );

        const leftWall = Bodies.rectangle(
            10,
            window.innerHeight / 2,
            20,
            window.innerHeight,
            { isStatic: true, render: { visible: false } }
        );

        const rightWall = Bodies.rectangle(
            window.innerWidth - 10,
            window.innerHeight / 2,
            20,
            window.innerHeight,
            { isStatic: true, render: { visible: false } }
        );

        World.add(engine.world, [ground, leftWall, rightWall]);

        // Setup columns
        function setupColumns() {
            const columnMatcher = document.getElementById('column-matcher');
            columnMatcher.innerHTML = '';

            for (let i = 0; i < 7; i++) {
                const column = document.createElement('div');
                column.className = 'matcher-column';
                column.dataset.columnIndex = i;
                column.addEventListener('click', () => handleColumnClick(i));
                columnMatcher.appendChild(column);
            }
        }

        // Setup pegs (lobby - blue circles)
        function setupPegs() {
            const pegPositions = [
                {x: 200, y: 200},
                {x: 300, y: 250},
                {x: 400, y: 200},
                {x: 500, y: 250},
                {x: 250, y: 350},
                {x: 350, y: 300},
                {x: 450, y: 350}
            ];

            pegPositions.forEach(pos => {
                // Create physics body
                const pegBody = Bodies.circle(pos.x, pos.y, 10, {
                    isStatic: true,
                    restitution: 0.8,
                    friction: 0.005,
                    render: { visible: false }
                });
                World.add(engine.world, pegBody);

                // Create visual element
                const pegElement = document.createElement('div');
                pegElement.className = 'peg';
                pegElement.style.width = '20px';
                pegElement.style.height = '20px';
                pegElement.style.left = (pos.x - 10) + 'px';
                pegElement.style.top = (pos.y - 10) + 'px';
                document.getElementById('game-container').appendChild(pegElement);
            });
        }

        // Create dice
        function createDice(x, emojiSet) {
            const diceElement = document.createElement('div');
            diceElement.className = 'dice';

            const diceInner = document.createElement('div');
            diceInner.className = 'dice-inner';

            // Create 6 faces
            for (let i = 0; i < 6; i++) {
                const face = document.createElement('div');
                face.className = 'dice-face';
                face.textContent = emojiSet[i % emojiSet.length];

                // Color based on emoji
                const emoji = emojiSet[i % emojiSet.length];
                face.style.background = getEmojiColor(emoji);

                diceInner.appendChild(face);
            }

            diceElement.appendChild(diceInner);
            document.getElementById('game-container').appendChild(diceElement);

            // Create physics body
            const diceBody = Bodies.rectangle(x, 50, 40, 40, {
                restitution: 0.6,
                friction: 0.01,
                frictionAir: 0.01
            });

            World.add(engine.world, diceBody);

            // Store dice info
            const diceData = {
                element: diceElement,
                body: diceBody,
                inner: diceInner,
                emojiSet: emojiSet,
                currentFace: 0,
                tumbleInterval: null,
                settled: false
            };

            gameState.activeDice.push(diceData);

            // Start tumbling
            startTumbling(diceData);

            return diceData;
        }

        // Get color based on emoji
        function getEmojiColor(emoji) {
            if (emoji === 'üßü‚Äç‚ôÇÔ∏è' || emoji === 'üßü‚Äç‚ôÄÔ∏è' || emoji === 'üíÄ') return '#a8e890';
            if (emoji === 'üë®' || emoji === 'üë©') return '#ffedd8';
            if (emoji === 'üî•') return '#ff9999';
            return '#f0f0f0';
        }

        // Start dice tumbling
        function startTumbling(diceData) {
            diceData.tumbleInterval = setInterval(() => {
                if (diceData.settled) {
                    clearInterval(diceData.tumbleInterval);
                    return;
                }

                const rx = Math.random() * 360;
                const ry = Math.random() * 360;
                const rz = Math.random() * 360;
                diceData.inner.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg) rotateZ(${rz}deg)`;

                diceData.currentFace = Math.floor(Math.random() * 6);
            }, 150);
        }

        // Update dice positions from physics
        Events.on(engine, 'afterUpdate', () => {
            gameState.activeDice.forEach(diceData => {
                const pos = diceData.body.position;
                diceData.element.style.left = (pos.x - 20) + 'px';
                diceData.element.style.top = (pos.y - 20) + 'px';

                // Check if settled in column
                if (!diceData.settled && Math.abs(diceData.body.velocity.y) < 0.1 && pos.y > window.innerHeight - 350) {
                    settleInColumn(diceData);
                }
            });
        });

        // Settle dice in column
        function settleInColumn(diceData) {
            diceData.settled = true;
            clearInterval(diceData.tumbleInterval);

            // Determine which column
            const columnIndex = Math.floor((diceData.body.position.x - 50) / (window.innerWidth / 7));
            const validColumn = Math.max(0, Math.min(6, columnIndex));

            // Remove from physics
            World.remove(engine.world, diceData.body);

            // Get final emoji
            const finalEmoji = diceData.emojiSet[diceData.currentFace % diceData.emojiSet.length];

            // Add to column
            addDiceToColumn(validColumn, finalEmoji, diceData.element);

            // Remove from active dice
            const index = gameState.activeDice.indexOf(diceData);
            if (index > -1) gameState.activeDice.splice(index, 1);

            // Check for matches after settling
            setTimeout(() => checkMatches(), 300);
        }

        // Add dice to column
        function addDiceToColumn(columnIndex, emoji, existingElement = null) {
            const column = document.querySelectorAll('.matcher-column')[columnIndex];

            if (gameState.columnStacks[columnIndex].length >= 8) {
                if (existingElement) existingElement.remove();
                return;
            }

            let diceEl;
            if (existingElement) {
                diceEl = existingElement;
                diceEl.style.position = 'relative';
                diceEl.style.left = '0';
                diceEl.style.top = '0';
            } else {
                diceEl = document.createElement('div');
                diceEl.className = 'dice';
                diceEl.style.position = 'relative';
                diceEl.innerHTML = `
                    <div class="dice-inner">
                        <div class="dice-face" style="background: ${getEmojiColor(emoji)}">${emoji}</div>
                    </div>
                `;
            }

            diceEl.dataset.emoji = emoji;
            column.appendChild(diceEl);
            gameState.columnStacks[columnIndex].push(emoji);
        }

        // Handle column click
        function handleColumnClick(columnIndex) {
            if (gameState.selectedColumn === null) {
                // Select column
                gameState.selectedColumn = columnIndex;
                document.querySelectorAll('.matcher-column')[columnIndex].classList.add('selected');
            } else if (gameState.selectedColumn === columnIndex) {
                // Deselect
                document.querySelectorAll('.matcher-column')[columnIndex].classList.remove('selected');
                gameState.selectedColumn = null;
            } else if (Math.abs(gameState.selectedColumn - columnIndex) === 1) {
                // Swap adjacent columns
                swapColumns(gameState.selectedColumn, columnIndex);
                document.querySelectorAll('.matcher-column')[gameState.selectedColumn].classList.remove('selected');
                gameState.selectedColumn = null;
            } else {
                // Select different column
                document.querySelectorAll('.matcher-column')[gameState.selectedColumn].classList.remove('selected');
                gameState.selectedColumn = columnIndex;
                document.querySelectorAll('.matcher-column')[columnIndex].classList.add('selected');
            }
        }

        // Swap columns
        function swapColumns(col1, col2) {
            const columns = document.querySelectorAll('.matcher-column');
            const stack1 = gameState.columnStacks[col1];
            const stack2 = gameState.columnStacks[col2];

            if (stack1.length === 0 || stack2.length === 0) return;

            // Swap top dice
            const topEmoji1 = stack1[stack1.length - 1];
            const topEmoji2 = stack2[stack2.length - 1];

            stack1[stack1.length - 1] = topEmoji2;
            stack2[stack2.length - 1] = topEmoji1;

            // Update visuals
            const dice1 = columns[col1].lastChild;
            const dice2 = columns[col2].lastChild;

            if (dice1) {
                dice1.dataset.emoji = topEmoji2;
                dice1.querySelector('.dice-face').textContent = topEmoji2;
                dice1.querySelector('.dice-face').style.background = getEmojiColor(topEmoji2);
            }
            if (dice2) {
                dice2.dataset.emoji = topEmoji1;
                dice2.querySelector('.dice-face').textContent = topEmoji1;
                dice2.querySelector('.dice-face').style.background = getEmojiColor(topEmoji1);
            }

            // Check for matches
            setTimeout(() => checkMatches(), 100);
        }

        // Check for matches
        function checkMatches() {
            const matches = [];

            // Check vertical matches (within columns)
            for (let col = 0; col < 7; col++) {
                const stack = gameState.columnStacks[col];
                let i = 0;
                while (i < stack.length) {
                    let matchLength = 1;
                    while (i + matchLength < stack.length && stack[i] === stack[i + matchLength]) {
                        matchLength++;
                    }
                    if (matchLength >= 2) {
                        matches.push({
                            type: 'vertical',
                            column: col,
                            startIndex: i,
                            length: matchLength,
                            emoji: stack[i]
                        });
                        i += matchLength;
                    } else {
                        i++;
                    }
                }
            }

            // Check horizontal matches (across top tiles)
            for (let col = 0; col < 6; col++) {
                if (gameState.columnStacks[col].length > 0 && gameState.columnStacks[col + 1].length > 0) {
                    const emoji1 = gameState.columnStacks[col][gameState.columnStacks[col].length - 1];
                    const emoji2 = gameState.columnStacks[col + 1][gameState.columnStacks[col + 1].length - 1];
                    if (emoji1 === emoji2) {
                        let matchLength = 2;
                        let endCol = col + 1;
                        while (endCol + 1 < 7 && gameState.columnStacks[endCol + 1].length > 0) {
                            const nextEmoji = gameState.columnStacks[endCol + 1][gameState.columnStacks[endCol + 1].length - 1];
                            if (nextEmoji === emoji1) {
                                matchLength++;
                                endCol++;
                            } else break;
                        }
                        matches.push({
                            type: 'horizontal',
                            startColumn: col,
                            length: matchLength,
                            emoji: emoji1
                        });
                        col = endCol;
                    }
                }
            }

            // Process matches
            if (matches.length > 0) {
                processMatches(matches);
            }
        }

        // Process matches
        function processMatches(matches) {
            matches.forEach(match => {
                const isSuper = match.length >= 3;
                showMatchIndicator(match, isSuper);

                // Apply match effects
                applyMatchEffect(match.emoji, match.length, isSuper);

                // Remove matched dice
                if (match.type === 'vertical') {
                    removeVerticalMatch(match);
                } else {
                    removeHorizontalMatch(match);
                }
            });

            updateUI();
        }

        // Apply match effect
        function applyMatchEffect(emoji, length, isSuper) {
            if (emoji === 'üë®' || emoji === 'üë©') {
                if (isSuper) {
                    gameState.humans += length;
                    gameState.score += 15;
                    showBonus(`+${length} HUMANS!`);
                } else {
                    gameState.humans += 1;
                    gameState.score += 5;
                    showBonus('+1 HUMAN');
                }
            } else if (emoji === 'üßü‚Äç‚ôÇÔ∏è' || emoji === 'üßü‚Äç‚ôÄÔ∏è') {
                if (isSuper) {
                    gameState.zombies = Math.max(0, gameState.zombies - length);
                    gameState.score += 30;
                    showBonus(`-${length} ZOMBIES!`);
                } else {
                    gameState.zombies = Math.max(0, gameState.zombies - 1);
                    gameState.score += 15;
                    showBonus('-1 ZOMBIE');
                }
            } else if (emoji === 'üíÄ') {
                if (isSuper) {
                    gameState.zombies = Math.max(0, gameState.zombies - 5);
                    gameState.score += 50;
                    showBonus('-5 ZOMBIES!');
                } else {
                    gameState.zombies = Math.max(0, gameState.zombies - 3);
                    gameState.score += 50;
                    showBonus('-3 ZOMBIES');
                }
            } else if (emoji === 'üí∞' || emoji === 'üí≥') {
                const diceBonus = isSuper ? 8 : 3;
                gameState.dicePool.mall += diceBonus;
                gameState.score += 25;
                showBonus(`+${diceBonus} DICE!`);
            } else {
                // Standard match
                gameState.dicePool.mall += 1;
                gameState.score += 10 * length;
            }
        }

        // Remove vertical match
        function removeVerticalMatch(match) {
            const column = document.querySelectorAll('.matcher-column')[match.column];
            const children = Array.from(column.children);

            for (let i = 0; i < match.length; i++) {
                const diceIndex = match.startIndex + i;
                if (children[diceIndex]) {
                    children[diceIndex].style.transform = 'scale(0)';
                    children[diceIndex].style.opacity = '0';
                    setTimeout(() => children[diceIndex].remove(), 300);
                }
            }

            gameState.columnStacks[match.column].splice(match.startIndex, match.length);
        }

        // Remove horizontal match
        function removeHorizontalMatch(match) {
            const columns = document.querySelectorAll('.matcher-column');

            for (let i = 0; i < match.length; i++) {
                const colIndex = match.startColumn + i;
                const column = columns[colIndex];
                const topDice = column.lastChild;

                if (topDice) {
                    topDice.style.transform = 'scale(0)';
                    topDice.style.opacity = '0';
                    setTimeout(() => topDice.remove(), 300);
                }

                gameState.columnStacks[colIndex].pop();
            }
        }

        // Show match indicator
        function showMatchIndicator(match, isSuper) {
            const indicator = document.createElement('div');
            indicator.className = 'match-indicator';
            indicator.textContent = isSuper ? 'SUPER MATCH!' : 'MATCH!';
            indicator.style.left = '50%';
            indicator.style.top = '40%';
            indicator.style.transform = 'translate(-50%, -50%)';
            indicator.style.fontSize = isSuper ? '32px' : '24px';
            indicator.style.color = isSuper ? 'gold' : 'yellow';

            document.getElementById('game-container').appendChild(indicator);
            setTimeout(() => indicator.remove(), 1000);
        }

        // Show bonus effect
        function showBonus(text) {
            const bonus = document.createElement('div');
            bonus.className = 'bonus-effect';
            bonus.textContent = text;
            bonus.style.left = '50%';
            bonus.style.top = '50%';
            bonus.style.transform = 'translate(-50%, -50%)';

            document.getElementById('game-container').appendChild(bonus);
            setTimeout(() => bonus.remove(), 2000);
        }

        // Update UI
        function updateUI() {
            document.getElementById('score-value').textContent = gameState.score;
            document.getElementById('zombie-value').textContent = gameState.zombies;
            document.getElementById('human-value').textContent = gameState.humans;
            document.getElementById('baby-value').textContent = gameState.babies;
            document.getElementById('shelter-value').textContent = gameState.shelters;

            // Update dice bag
            updateDiceBag();

            // Update dice stack
            updateDiceStack();

            // Update make baby button
            const makeBabyBtn = document.getElementById('make-baby-btn');
            makeBabyBtn.disabled = gameState.humans < 2;
        }

        // Update dice bag
        function updateDiceBag() {
            const bagContent = document.getElementById('dice-bag-content');
            bagContent.innerHTML = '';

            const diceTypes = [
                { key: 'mall', name: 'Mall Dice', emoji: 'üõçÔ∏è' },
                { key: 'food', name: 'Food Dice', emoji: 'üçï' },
                { key: 'arcade', name: 'Arcade Dice', emoji: 'üéÆ' },
                { key: 'clothing', name: 'Clothing Dice', emoji: 'üëó' },
                { key: 'zoo', name: 'Zoo Dice', emoji: 'üêÖ' },
                { key: 'themepark', name: 'Park Dice', emoji: 'üé°' }
            ];

            diceTypes.forEach(type => {
                if (gameState.dicePool[type.key] > 0) {
                    const group = document.createElement('div');
                    group.className = 'dice-group';
                    group.innerHTML = `
                        <div class="dice-group-left">
                            <span class="dice-group-emoji">${type.emoji}</span>
                            <span class="dice-group-name">${type.name}</span>
                        </div>
                        <span class="dice-group-count">${gameState.dicePool[type.key]}</span>
                    `;
                    bagContent.appendChild(group);
                }
            });
        }

        // Update dice stack
        function updateDiceStack() {
            const stack = document.getElementById('dice-stack');
            stack.innerHTML = '';

            // Show mall dice in lobby
            if (gameState.dicePool.mall > 0) {
                emojiSets.mall.forEach(emoji => {
                    const item = document.createElement('div');
                    item.className = 'dice-stack-item';
                    item.textContent = emoji;
                    item.style.background = getEmojiColor(emoji);
                    item.addEventListener('click', () => dropDice(emoji));
                    stack.appendChild(item);
                });
            }
        }

        // Drop dice
        function dropDice(emoji) {
            if (gameState.dicePool.mall <= 0) return;

            gameState.dicePool.mall--;

            const emojiSet = emojiSets.mall;
            const startX = window.innerWidth / 2 + (Math.random() - 0.5) * 200;

            createDice(startX, emojiSet);
            updateUI();
        }

        // Make baby
        document.getElementById('make-baby-btn').addEventListener('click', () => {
            if (gameState.humans >= 2) {
                gameState.humans -= 2;
                gameState.babies += 1;
                gameState.parentsDice.push('parent', 'parent');

                showBonus('üë® + üë© = üë∂');

                // Start baby growth timer if shelters > 0
                if (gameState.shelters > 0) {
                    setTimeout(() => {
                        if (gameState.babies > 0) {
                            gameState.babies--;
                            gameState.humans++;
                            showBonus('Baby grew up!');
                            updateUI();
                        }
                    }, 30000);
                }

                updateUI();
            }
        });

        // Initialize game
        function initGame() {
            setupColumns();
            setupPegs();
            updateUI();

            // Start engines
            Engine.run(engine);
            Render.run(render);
        }

        // Start game when loaded
        window.addEventListener('load', initGame);

        // Handle window resize
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
